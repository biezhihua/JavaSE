## 基本类型

| 基本类型 | 字节 | 包装类型 |
| ---- | ---- | ---- |
|byte |1字节| Byte |
|short  | 2字节  |   Short|
|int   |  4字节   |  Integer|
|long  |  8字节    | Long|
|float |  4字节   |  Float|
|double | 8字节    | Double|
|boolean |1字节    | Boolean|
|char |1字节    | Character|

## switch()中能否使用string作为参数

JavaSE5之前：byte,short,int,char
JavaSE5时：增加enum类型
JavaSE7时：增加string

目前始终不支持的long

## Java的四中引用

- 强引用（Strong Reference） 最常用的引用类型，如Object obj = new Object(); 。只要强引用存在则GC时则必定不被回收。
- 软引用（Soft Reference） 用于描述还有用但非必须的对象，当堆将发生OOM（Out Of Memory）时则会回收软引用所指向的内存空间，若回收后依然空间不足才会抛出OOM。一般用于实现内存敏感的高速缓存。 当真正对象被标记finalizable以及的finalize()方法调用之后并且内存已经清理, 那么如果SoftReference object还存在就被加入到它的 ReferenceQueue.只有前面几步完成后,Soft Reference和Weak Reference的get方法才会返回null
- 弱引用（Weak Reference） 发生GC时必定回收弱引用指向的内存空间。 和软引用加入队列的时机相同.
- 虚引用（Phantom Reference) 又称为幽灵引用或幻影引用，虚引用既不会影响对象的生命周期，也无法通过虚引用来获取对象实例，仅用于在发生GC时接收一个系统通知。 当一个对象的finalize方法已经被调用了之后，这个对象的幽灵引用会被加入到队列中。通过检查该队列里面的内容就知道一个对象是不是已经准备要被回收了. 虚引用和软引用和弱引用都不同,它会在内存没有清理的时候被加入引用队列.虚引用的建立必须要传入引用队列,其他可以没有

错误的使用方式，常常使用Handler时会报警告，为了不让内部类隐式引用外部类对象而把Handler变成静态的，而一般来说其内部我们都会使用到Context对象来引用上下文，同时为了不内存泄露，常常会把Context变成弱引用（按照网上的例子），这个时候如果我们利用Handler的延迟效果来做一些事情，当GC发生是就会出现一些意外的情况，因为Context在GC发生是被释放掉了。

## == 和 equals()

区别:
1. ==侧重于比较原生类型（byte/short/int/long..），而equals()侧重于检查对象的相等性。
2. ==是操作符，而equals()是方法
3. ==如果用于比较对象，比较的是内存地址，而equals()分为两种情况，如果没有重写Object的equals()方法，则是比较内存地址，如果重写了则是按照具体的业务逻辑来比较，例如String就是比较实际的内容。

正确的equals()方法必须满足以下5个条件:
1. 自反性.对任意x,x.equals(x)一定返回true.
2. 对称性.对任意x/y,如果y.equals(x)返回true,则x.equals(y)也返回true
3. 传递性.对任意x/y/z,如果有x.equals(y)返回true,y.equals(z)返回true,则x.equals(z)一定返回true.
4. 一致性.对任意x/y,如果对象中用于等价比较的信息没有改变,那么无论如何调用x.equals(y)多少次,返回的结果应该保持一致,那么一直是true,要么一直是false
5. 对任何不是null的x,x.equals(null)一定返回false.

## HashCode（散列码）的作用
说到HashCode就必须提到Java中的集合。例如Map，对于集合操作一般分为存和取，因为Map的key不保存重复的元素，所以加入Map中的元素必须定义equals()方法，以确定对象的唯一性（是否相等）。

在取的情况下，如果遍历去拿指定的key，无意很耗费效率。而HashCode()就是为了速度而生。例如HashMap，就必须同时定义equals()和hashCode()方法。

hashCode称为散列码，生成散列码的函数叫做散列函数，而一般使用散列码的原因在于想使用一个对象去查找另一个对象（HashMap）。线性查询的瓶颈在于查询速度。

散列将键的信息保存在某处,以便能快速找到(数组是存储元素最快的数据结构).通过键对象生成一个数字,将其作为数组的下标,这个数字就是散列码,由散列函数(Object.hashCode())生成.

为了解决数组容量被固定的问题,不同的键可以产生相同的下标.也就是说可能会有冲突,因此数组多大也就不重要了,任何键都能在数组中找到他的位置.

查询一个值的过程首先就是计算散列码,然后使用散列码查询数组,如果能够保证没有冲突(如果值的数量是固定的,那么就有可能冲突),那么就有了一个完美的散列函数.

通常,冲突由外部链接处理:数组并不直接保存值,而是保存值的list.然后对list中的值使用equals()方法进行线性的查询.

如果散列函数比较好,数组的每个list就会有比较少的值.

因此不是查询整个list,而是快速的跳到数组的某个位置,只对很少的元素进行比较.这就是HashMap会如此快的原因.

由于散列表中的"槽位 slot"通常称为捅位(bucket),为了使散列均匀分布,桶的数量通常使用2的整数次方,因为除法和求余是最慢的操作,可以用掩码来替代.

怎么重写hasCode()函数:
1. 给int变量result赋予某个非零值常量
2. 为对象内有意义的域(即每个可以做equals()的域)计算出一个int散列码c
4. 合并计算的得到的散列码 result = 31 * result + c;
4. 返回result

|域类型|计算|
| --- | --- |
| boolean               | c = f ? 0 : 1|
| byte/char/short/int   | c = (int)f;  |
| long                  | c = (int)(f ^ f>>>32)  |
| float                 | c = Float.floatToInBits(f);  |
| double                | long l = Double.doubleToLongBits(f); c = (int)(l ^ (l>>>32));  |
| Object                | c = f.hashCode();  |
| 数组                  |  对每个元素应用应用以上规则  |

String类的hashCode如下:
```java
public int hashCode() {
    int h = hash;
    if (h == 0 && value.length > 0) {
        char val[] = value;

        for (int i = 0; i < value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    return h;
}
```

设计者选择 31 这个值是因为它是一个奇质数。如果它是一个偶数，在使用乘法当中产生数值溢出时，原有数字的信息将会丢失，因为乘以二相当于位移。
选择质数的优势不是那么清晰，但是这是一个传统。31 的一个优良的性质是：乘法可以被位移和减法替代：

```java
31 * i == (i << 5) - i
```

现代的 VM 可以自行完成这个优化。

此外,可以手工调整HashMap来提高性能: 
1. 容量：桶位数 
2. 初始容量：在创建是所拥有的捅位数．HashMap和HashSet都允许设置． 
3. 尺寸：表中当前存储的项数． 
4. 负载因子：尺寸／容量．空表的负载因子是0,而半满的负载因子是0.5.负载轻的表,出产生冲突的可能性小,对于插入和查找都是最理想的. 
HashMap和HashSet都允许指定负载因子,当达到负载因子的水平时,容器将自动增加其容量(桶位数),实现方式是容量大致加倍,并重新将现有的对象分部到新的捅位中,称之为再散列. 
A` HashMap使用的负载因子是0.75(只有当表达到四分之三时,才进行散列),这个因子在时间和空间代价中达到了平衡,更高的负载因子可以降低表所需的空间,但是会增加查找的代价.

HashMap不是线程安全的，在被多线程共享操作时，会有问题，什么问题呢: 
主要是多线程同时put时，如果同时触发了再散列操作，会导致HashMap中的链表中出现循环节点，进一步是的后面get的时候，会死循环。

线程不安全的HashMap:
因为多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。

效率低下的HashTable容器:
HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。
因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。
如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。

ConcurrentHashMap的锁分段技术:
HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，
那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，
首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。
     
HashMap的基本概念:
在JDK1.6中，HashMap采用Node数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。
但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。
而JDK1.8中，HashMap采用Node数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。

## String/StringBuilder/StringBuffer

String是不可变类型的。
StringBuilder是线程不安全的可变类型。
StringBuffer是线程安全的可变类型。
在使用StringBuilder和StringBuffer的时候是有陷阱的，如果在append("a"+"b")这样使用就掉入了陷阱，因为"a+"b"会生成新的字符串。

## try catch finally，try里有return，finally还执行么？

会执行，在方法 返回调用者前执行。Java允许在finally中改变返回值的做法是不好的，
因为如果存在finally代码块，try中的return语句不会立马返回调用者，而是记录下返回值，待finally代码块执行完毕之后再向调用者返回其值，
然后如果在finally中修改了返回值，这会对程序造成很大的困扰。

## Exception与Error区别

Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的状况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。

## 集合

Java集合工具包位于Java.util包下，包含了很多常用的数据结构，如数组、链表、栈、队列、集合、哈希表等。

学习Java集合框架下大致可以分为如下五个部分：List列表、Set集合、Map映射、迭代器（Iterator、Enumeration）、工具类（Arrays、Collections）。

Collection是List、Set等集合高度抽象出来的接口，它包含了这些集合的基本操作，它主要又分为两大部分：List和Set。

List接口通常表示一个列表（数组、队列、链表、栈等），其中的元素可以重复，常用实现类为ArrayList和LinkedList，另外还有不常用的Vector。另外，LinkedList还是实现了Deque(Deque继承自Queue)接口，因此也可以作为队列使用。

Set接口通常表示一个集合，其中的元素不允许重复（通过hashcode和equals函数保证），常用实现类有HashSet和TreeSet，HashSet是通过Map中的HashMap实现的，而TreeSet是通过Map中的TreeMap实现的。另外，TreeSet还实现了SortedSet接口，因此是有序的集合（集合中的元素要实现Comparable接口，并覆写Compartor函数才行）。

可以看到，抽象类AbstractCollection、AbstractList和AbstractSet分别实现了Collection、List和Set接口，这就是在Java集合框架中用的很多的模板（而非适配器）设计模式，用这些抽象类去实现接口，在抽象类中实现接口中的若干或全部方法，这样下面的一些类只需直接继承该抽象类，并实现自己需要的方法即可，而不用实现接口中的全部抽象方法。

Map是一个映射接口，其中的每个元素都是一个key-value键值对，同样抽象类AbstractMap通过模板模式实现了Map接口中的大部分函数，TreeMap、HashMap、WeakHashMap等实现类都通过继承AbstractMap来实现，另外，不常用的HashTable继承自Dictionary并直接实现了Map接口，此外它还是线程安全的（简单粗暴的使用synchronized，所以效率较低），它和Vector都是JDK1.0就引入的集合类。

Iterator是遍历集合的迭代器（不能遍历Map，只用来遍历Collection），Collection的实现类都实现了iterator()函数，它返回一个Iterator对象，用来遍历集合，ListIterator则专门用来遍历List。而Enumeration则是JDK1.0时引入的，作用与Iterator相同，但它的功能比Iterator要少，它只能再Hashtable、Vector和Stack中使用。

Arrays和Collections是用来操作数组、集合的两个工具类，例如在ArrayList和Vector中大量调用了Arrays.Copyof()方法，而Collections中有很多静态方法可以返回各集合类的synchronized版本，即线程安全的版本，当然了，如果要用线程安全的结合类，首选Concurrent并发包下的对应的集合类。

## HashMap

http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/

1. 什么时候会使用HashMap？他有什么特点？

是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。

2. 你知道HashMap的工作原理吗？

通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。

3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？

通过对key的hashCode()进行hashing，并计算下标( n-1 & hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点

4. 你知道hash的实现吗？为什么要这样实现？

在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h >>> 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。

5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？

如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。

## ConcurrentHashMap

在以前的版本貌似ConcurrentHashMap引入了一个“分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。在ConcurrentHashMap中，就是把Map分成了N个Segment，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中。
通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，但是效率提升N倍。

## LinkList

1. LinkedList是基于双向链表（从源码中可以很容易看出）实现的，除了可以当做链表来操作外，它还可以当做栈、队列和双端队列来使用。
2. LinkedList同样是非线程安全的，只在单线程下适合使用。
3. 以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。
4. 按下标访问元素—get(i)/set(i,e) 要悲剧的遍历链表将指针移动到位(如果i>数组大小的一半，会从末尾移起)。
5. 插入、删除元素时修改前后节点的指针即可，但还是要遍历部分链表的指针才能移动到下标所指的位置，只有在链表两头的操作—add(), addFirst(),removeLast()或用iterator()上的remove()能省掉指针的移动。

## ArrayList

1. 以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。
2. 按数组下标访问元素—get(i)/set(i,e) 的性能很高，这是数组的基本优势。
3. 直接在数组末尾加入元素—add(e)的性能也高，但如果按下标插入、删除元素—add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。

## CopyOnWriteArrayList

并发优化的ArrayList。用CopyOnWrite策略，在修改时先复制一个快照来修改，改完再让内部指针指向新数组。
因为对快照的修改对读操作来说不可见，所以只有写锁没有读锁，加上复制的昂贵成本，典型的适合读多写少的场景。如果更新频率较高，或数组较大时，还是Collections.synchronizedList(list)，对所有操作用同一把锁来保证线程安全更好。
增加了addIfAbsent(e)方法，会遍历数组来检查元素是否已存在，性能可想像的不会太好。

CopyOnWriteArrayList中,写入将导致创建整体底层数组的副本,而源数组将保留在原地,使得复制的数组在被修改时,读取操作可以安全的执行. 当修改完成时,一个原子性的操作将把新的数组换入,使得新读取的操作可以看到这个新的修改.
CopyOnWriteArrayList的好处之一就是当多个迭代器同时遍历和修改这个列表时,不会抛出异常.
CopyOnWriteArraySet内部使用CopyOnWriteArrayList来实现其免锁行为. "使用了类似的基数,允许并发的读取和写入,但是容器中只有部分内容而不是整个容器可以被复制和修改.
然而,在任何修改完成之前,读取者仍然看不到他们.

## ArrayBlockQueue

是一个由数组支持的有界阻塞队列。此队列按 FIFO（先进先出）原则对元素进行排序。队列的头部 是在队列中存在时间最长的元素。队列的尾部 是在队列中存在时间最短的元素。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。 这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。 此类支持对等待的生产者线程和消费者线程进行排序的可选公平策略。默认情况下，不保证是这种排序。然而，通过将公平性 (fairness) 设置为 true 而构造的队列允许按照 FIFO 顺序访问线程。公平性通常会降低吞吐量，但也减少了可变性和避免了“不平衡性”。


##  双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。

双亲委派模型:
1. 启动类加载器，负责将存放在\lib目录中的，或者被-Xbootclasspath参数所指定的路径中，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即时放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被java程序直接引用。
2. 扩展类加载器：负责加载\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用该类加载器。
3. 应用程序类加载器：负责加载用户路径上所指定的类库，开发者可以直接使用这个类加载器，也是默认的类加载器。 三种加载器的关系：启动类加载器->扩展类加载器->应用程序类加载器->自定义类加载器。

这种关系即为类加载器的双亲委派模型。其要求除启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不以继承关系实现，而是用组合的方式来复用父类的代码。

双亲委派模型的工作过程：如果一个类加载器接收到了类加载的请求，它首先把这个请求委托给他的父类加载器去完成，每个层次的类加载器都是如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它在搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

好处：java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar中，无论哪个类加载器要加载这个类，最终都会委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果用户自己写了一个名为java.lang.Object的类，并放在程序的Classpath中，那系统中将会出现多个不同的Object类，java类型体系中最基础的行为也无法保证，应用程序也会变得一片混乱。

实现：在java.lang.ClassLoader的loadClass()方法中，先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载失败，则抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。

## GC

CG:
1. 标记－清扫，所依据的思路是从堆栈和静态存储区出发，遍历所有的引用，进而找出所有存活的对象．每当它找到一个存活对象，就会给对象设一个标记，
这个过程中不会回收任何对象．只有标记工作完成的时候，清理动作才会开始．在清理的过程中，没有标记的对象将会被释放，不会发生任何复制动作．
所以剩下的堆空间是不连续的，垃圾回收器要是希望得到连续的空间的话，就的重新整理剩下的对象．
2. 停止－复制，的意思是这种垃圾回收动作不是在后台进行的，相反，垃圾回收动作发生的同时，程序将会被暂停．停止－复制要求在释放旧有对象之前，
必须先把所有存活的对象从旧堆复制到新堆，这将导致大量的复制行为．
3. Java虚拟机会进行监视，如果所有对象都很稳定，垃圾回收期的效率低的话，会切换到标记－清扫方式，根据效果，要是堆空间出现很多碎片，就会切换到停止－复制．

## JVM区域划分
JVM所管理的内存分为以下几个运行时数据区：程序计数器、Java虚拟机栈、本地方法栈、Java堆、方法区。

Java堆:
Java Heap是Java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。Java Heap是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。

方法区:
是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区域又被称为“永久代”.

Java堆中各代分部 yong(年轻代)  old(老年代) permanent(方法区):
1. Young：主要是用来存放新生的对象。
2. Old：主要存放应用程序中生命周期长的内存对象。
3. Permanent：是指内存的永久保存区域，主要存放Class和Meta的信息,Class在被 Load的时候被放入PermGen space区域. 它和和存放Instance的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的APP会LOAD很多CLASS的话,就很可能出现PermGen space错误。

## CountDownLatch

它被用来同步一个或者多个任务,强制他们等待由其他任务执行的一组操作完成.

可以像CountDownLatch对象设置一个初始计数值,任何在这个对象上调用wait()的方法都会将阻塞,直至这个计数值达到0. 其他任务在结束其工作任务时,可以在该对象上调用countDown()来减小这个计数值.

CountDownLatch被设计为只触发一次,计数值不能被重置.如果你需要能够重置计数值的版本,则可以使用CyclicBarrier

## CyclicBarrier

希望创建一组任务,他们并行地执行工作,然后在进行下一步骤之前等待,直至所有的任务都完成.这使得所有的并行任务 都将在栅栏处列队,因此可以一致的向前移动.

## DelayQueue

无界的BLockingQueue,用于放置实现了Delayed接口的对象,其中的对象指正在其到期时才能从队列中走出. 这种队列是有序的,即队头对象的延迟到期的时间最长.如果没有任何延迟到期,那么就不会由任何头元素,并且poll会null

## PriorityBlockingQueue

优先级队列,他具有可阻塞的读取操作.

## 死锁
   
某个任务在等待另一个任务,而后者又在等待别的任务,这样一直下去,直到这样链条上的任务 又在等待第一个任务释放锁.这得到了一个任务之间相互等待的联系循环,没有那个线程能够继续,称之为死锁.

当以下四个条件同时满足时,就会发生死锁:

互斥条件.任务使用的资源中至少有一个是不能共享的.
至少有一个任务它必须持有一个资源且正在等待获取一个当前被别的任务持有的资源.
资源不能被任务抢占,任务必须把资源释放当做普通事件.
必须有循环等待,这时,一个任务等待其他任务所持有的资源,后者又在等待另一个任务持有的资源,直到有一个任务在等待第一个任务所持有的资源, 使得大家都被锁住.
因为要发生死锁的化,所有这些条件必须全部满足;所以要防止死锁的话,只需破坏其中一个即可.

## 中断
   
Thread.interrupt()用于终止被阻塞的任务.
Thread.interrupted()提供了离开run()循环而不抛出异常的第二种方式.
Executor.submit()可以获取一个Future任务的上下文,可以调用cancel()方法取消任务.其内部是通过interrupt()以停止这个线程的.
可以中断对sleep()的调用,或者是任何要求抛出InterruptedException的调用.但是,不能中断正在试图获取synchronized锁或者是试图执行I/O操作的线程.

## 在阻塞时终结

线程状态,一个线程可以处于以下四种状态:
1. 新建(new):当线程被创建时,它只会短暂的处于这种状态.此时它已经分配了必须的系统资源,并执行了初始化.此刻线程已经有资格获得CPU时间了,之后调度器将把这个线程 转变位可运行状态或阻塞状态.
2. 就绪(runnable):在这种状态下,只要调度器把时间片分配给线程,线程就可以运行.也就是说,在任意时刻,线程可以运行也可以不运行.只要调度器能分配时间片给线程,他就可以运行 这不同于死亡和阻塞状态.
3. 阻塞(Blocked):线程能够运行,但有个条件阻止它的运行.当线程处于阻塞状态时,调度器将忽略线程,不会分配时间片给线程任何CPU时间.知道线程重新进入了就绪状态,他才有可能执行操作.
4. 死亡(Dead):处于死亡或终止状态的线程不在是可调度的,并且再也不会得到CPU时间,它的任务已结束,或不在是可运行的.任务死亡的方式通常是从run()方法返回,但是任务的 还可以被中断.

进入阻塞状态,一个线程进入阻塞状态,可能有如下原因:
1. 通过调用sleep(millseconds)使任务进入休眠状态,在这种状态下,任务在指定的时间内不会运行.
2. 通过wait()使线程挂起.直到线程得到了notify()或notifyAll()消息,或是signal()和singalAll(),线程才会进入就绪状态.
3. 任务在等待某个输入/输出完成.
4. 任务试图在某个对象上调用其同步控制方法,但是对象锁不可用,因为另一个任务已经获取了这个锁.

## 线程本地存储
   
防止任务在共享资源上产生冲突的第二种方式是根除对变量的共享. 线程本地存储是一种自动化机制,可以为使用相同变量的每个不同的线程创建不同的存储. 如果由5个线程都要使用变量x所表示的对象,那线程本地存储就会生成5个用于x的不同存储快.他们可以使得你将状态和线程关联起来.
   
创建和管理线程本地存储由ThreadLocal类来实现.

## 原子性与易变性
   
原子性可以应用于除long和double之外的所有基本类型智商的"简单操作".对于读取和写入除long和double之外的基本类型变量这样的操作,可以保证他们会被当做不可分的操作来操作内存.6tgc

原子性可以应用于除long和double之外的所有基本类型上的简单操作.

valatile关键是确保了可视性,如果产生了写操作,那么所有的读操作都可以看到这个修改.

什么属于原子操作?对域中的值做赋值和返回操作通常都是原子性的.

在java中 i++; i+=2;不是原子性的.

基本上,如果一个域可能会被多个任务同时访问,或者这些任务至少有一个是写入任务,那么你就应该将这个域设置位volatile的.如果将一个域定义为 volatile,那么它会告诉编译器不要执行任何移除读取和写入操作的优化,这些操作的目的是用线程中的局部变量维护对这个域的精准同步. 实际上,读取和写入都是直接针对内存的,而却没有被缓存.但是,valatile并不能对递增不是原子性操作这一事实产生影响.

## 原子类

AtomicInteger AtomicLong AtomicReference

## 解决共享资源竞争

你永远不知道一个线程何时在运行.

对于并发工作,需要某种方式来防止两个任务访问相同的资源,至少在关键阶段不能出现这种情况.

基本上所有的并发模式在解决线程冲突的问题时,都是采用序列化访问共享资源的方案.

这意味着在给定的时刻只允许一个任务访问共享资源.这通常是在代码前面加上一条锁语句,使得在一段时间内只有一个任务运行这段代码.

因为锁语句产生了一种互相排斥的效果,所以这种机制常常称为互斥量. mutex.

synchronized防止资源冲突提供了内置支持.当要执行的任务被synchronized关键字保护的代码片段时,检查锁是否可用,然后获取锁,执行代码,释放锁.

在使用并发时,将域设置位private是非常重要的,否则,synchronized关键字就不能防止其他任务直接访问域,这样就会产生冲突.

所有对象都自动含有单一的锁(监视器).当在对象上调用任意的synchronized方法时,此对象都被枷锁,这时该对象上的其他synchronized方法只有等到前一个方法调用完毕 并释放了锁之后,其他任务才能调用f()和g().

针对每个类,也有一个锁,作为类Class对象的一部分,所以synchronized static 方法可以在类范围内防止对static数据的并发访问.

什么时候使用同步?

如果你正在写一个变量,他可能接下来被另一个线程读取,或者正在读取上一次已经被另一个线程写过的变量,那么你必须使用同步,并且读写线程都必须使用相同的监视器锁同步.

## 后台 daemon 线程

是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的一部分． 当所有非后台线程结束时，程序也就终止了，同时会杀死进程中所有的后台线程．

必须在线程启动之前调用setDaemon()方法，才能把其设置为后台线程．

可以通过isDaemon()来确定线程是否是一个后台线程，如果是一个后台线程，呢么它创建的任何线程都被自动设置成后台线程．

后台线程在不执行finally子句的情况下就会终止其run()方法．因为，当一个非后台线程终止时，后台线程会＂突然＂终止. 因此,一旦main()退出,JVM就会立即关闭所有的后台线程.

## 继承／封装／多态

一个要形象，一个要具体。

形象来说：

比如女娲造人，在造人的时候是以自己为模板的，有鼻子，有眼睛，有身体，有四肢。而造出的男人和女人，一出生就具有了这些基本特征，这个就是继承。
将血液，内脏，大脑这些数据封装在人的模板中，并提供思考，走路，吃饭等行为就是封装。
而多态性则是，对模板的继承，有不同的演绎，比如果都是人，但是分为男人和女生，而男人和女生，在生理特征上有很大不同的，这就是多态性。
还比如，当我去买彩票时，彩票中心接待的是人，无论是男人，女人，或者是小孩子，或是有病的没病的，只要是概念上的人等，都可以买彩票，这也是多态性的体现。

具体来说：

Java的继承用extends关键字来实现，被继承的类成为父类，实现继承的类被称为子类。子类和父类的关系就比如现实生活中儿子与父亲的关系。子类继承父类所有的“特点”，子类是父类的扩展，子类是一种特殊的父类，获得父类的全部属性和方法。

封装是指将对象的状态信息隐藏在对象内部，不允许外部的程序直接访问对象内部的信息，而是通过该类所提供的方法来实现对内部信息的操作和访问。

多态性指的是一个方法可以有多个实现的版本，对于一个方法的多种实现，在程序运行时，系统会根据方法的参数和方法的对象自动选择一个合适的方法执行，而不是产生混乱。
类的多态性表现为方法的多态性，讨论在不同层次的类中以及在同一个类中，多个同名方法之间的关系问题。方法的多态性主要表现在方法的重载和方法的覆盖。
方法的重载
    重载是指同一个类中的多个方法可以同名但是参数列表不同。
方法的覆盖
    覆盖是指子类重新定义了父类的同名方法。详见此篇博客上部分。
运行时多态
    多态性有两种：编译时多态和运行时多态。
    1. 编译时多态性
    对于多个同名方法，如果在编译时就能确定执行同名方法的哪一个，则称为编译时多态。方法的重载就是编译时多态。
    2. 运行时多态性
    如果在编译时不能确定多个同名方法的哪一个，只能在运行的时候才能确定，就称为是运行时多态。
    方法的覆盖表现两种多态性，当对象获得本类的实例时，是编译时多态，否则就是运行时多态。

## abstract和interface的区别 / 什么情况下使用interface，什么情况下使用abstract类

abstract class和interface是支持抽象类定义的两种机制。

http://blog.csdn.net/b271737818/article/details/3950245

男人是一个人，而不能说男人像一个人，除非他是禽兽。
钢铁侠是一个男人，但是拥有机甲，可以说他象鸟，但不能说他是鸟。　

## 对多态的理解

先阐述一下，多态性的语法概念，在说下形象的例子。

有一个饭馆，饭馆可以招待客人，饭馆老板很好，在饭馆外给流浪动物吃的。　客人可以吃东西，动物可以东西，所以这个饭馆接待的是具有吃饭这个行为的个体或对象。

吃饭，男人，女人，小孩，小狗，宠物。

## 线程sleep()和wait()有何区别，各有什么含义。

sleep指线程被调用时，占着CPU不工作，形象地说明为“占着CPU睡觉”，此时，系统的CPU部分资源被占用，其他线程无法进入，会增加时间限制。
wait指线程处于进入等待状态，形象地说明为“等待使用CPU”，此时线程不占用任何资源，不增加时间限制。
所以
sleep（100L）意思为：占用CPU，线程休眠100毫秒
wait（100L）意思为：不占用CPU，线程等待100毫秒

## array和arrayList,list三者有什么区别

## hashTable和hashMap的区别

hastTable和hashMap都是存放数据的集合。
不同之处在于hashTable不允许null值和key值，同时是线程安全的。
而hashMap非线程安全，同时允许null值和key值。

## JavaGC机制的原理和内存泄露

Generational Collection（分代收集）算法

分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

目前大部分垃圾收集器对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。

而由于老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法。

注意，在堆区之外还有一个代就是永久代（Permanet Generation），它用来存储class类、常量、方法描述等。对永久代的回收主要回收两部分内容：废弃常量和无用的类。

## 多线程中的安全队列一般通过什么实现？线程池原理

http://blog.csdn.net/madun/article/details/20313269

## socket断线重连怎么实现，心跳机制是怎么实现，三次握手和四次挥手步骤

http://blog.csdn.net/biezhihua/article/details/52290908

## Http中TCP和UDP有啥区别。

http://blog.csdn.net/biezhihua/article/details/52292267

## 安全加密有哪些

## 你知道的数据存储结构？堆栈和链表内部的机制。

数组，链表，堆栈，树

## Linux进程和线程的区别。

http://blog.csdn.net/forrest2009/article/details/6413756
